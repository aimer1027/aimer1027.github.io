{"name":"leetcodes.word-pattern","tagline":"aimer's blog","body":"# Word Pattern\r\n[linker to leetcode](https://leetcode.com/problems/word-pattern/)\r\n\r\nDescriptions:\r\n\r\nGiven a pattern and a string str, find if str follows the same pattern.\r\n\r\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\r\n\r\nExamples:\r\npattern = \"abba\", str = \"dog cat cat dog\"  should return true.<br/>\r\npattern = \"abba\", str = \"dog cat cat fish\"  should return false.<br/>\r\npattern = \"aaaa\", str = \"dog cat cat dog\"  should return false.<br/>\r\npattern = \"abba\", str = \"dog dog dog dog\"  should return false.<br/>\r\nNotes:<br/>\r\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\r\n\r\n\r\n * 1. how to split a string into substring array\r\n * 2. how to use map\r\n * 3. master the concept of <b> 'bijection '</b> which means two sets f, g\r\n >*    f(x) = y, x is an element in f , y is belong to g \r\n >*    on th other hand, g(a) = b ; a is an element in set g , and b is belong to f\r\n >*    something you should pay attention to is that , a ,b,x ,y is unique which mean \r\n >*    if there is g(a) = b , g(k) =b or g(a) = m , g(k) = m, these situations are all wrong \r\n \r\n ##here are the steps to solve the problem:\r\n * i use map to help me solve the problem of bijection \r\n * split the str into small sub-strings by substr provided by string\r\n * justify the pattern's length is equal to sub-string arrays', if lenth not match , false\r\n * travers the pattern \r\n > for i = 0 --> pattern.size()-1<br/>\r\n > if there is no elemenet with key = pattern.at(i) <br/> \r\n >    no element with value = sub-string.at(i) && the key of the value not match pattern(i)<br/>\r\n >    insert the pair<key,value> into the map\r\n > if there is an element with key = pattern.at(i) and the value = sub-string.at(i)<br/>\r\n >     just continue the loop<br/>\r\n > if there is an element with key = pattern.at(i) however the value not match sub-string.at(i)<br/>\r\n >     set the flag to false , and break the circle     \r\n \r\nsource code:\r\n\r\n````c++\r\nclass Solution {\r\npublic:\r\n  \r\n\t\tbool wordPattern(string pattern, string str) {\r\n\r\n\t\tint from, to;\r\n\t\tstring temp;\r\n\t\tvector<string> subArr;\r\n\t\tmap<char, string> pairs;\r\n\r\n\r\n\t\tfrom = 0;\r\n\t\tto = str.find(\" \", from);\r\n\t\ttemp = str.substr(from, to - from);\r\n\r\n\t\tsubArr.push_back(temp);\r\n\r\n\t\twhile (to != -1) {\r\n\t\t\tfrom = to + 1;\r\n\t\t\tto = str.find(\" \", from);\r\n\r\n\t\t\t\r\n\t\t\ttemp = str.substr(from, to - from);\r\n\t\t\tsubArr.push_back(temp);\r\n\r\n\t\t}\r\n\t\t \r\n\t\tif (subArr.size() != pattern.size())\r\n\t\t\treturn false;\r\n\r\n\t\tmap<char, string>::iterator it;\r\n\t\tmap<char, string>::iterator it2;\r\n\r\n\t\tbool flag = true;\r\n\r\n\t\tfor (int i = 0; i < pattern.size(); i++) {\r\n\r\n\t\t\tit = pairs.find(pattern.at(i));\r\n\r\n\t\t\tif (it == pairs.end()) {\r\n\t\t\t\t// 当且仅当，在 pairs 的pairs 中没有 value 相同，但是 key 不同的元素存在\r\n\r\n\t\t\r\n\r\n\t\t\t\tfor (it2 = pairs.begin(); it2 != pairs.end(); it2++) {\r\n\t\t\t\t\tif (it2->second == subArr.at(i) && it2->first != pattern.at(i)) {\r\n\t\t\t\t\t\tflag = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\tpairs.insert(make_pair(pattern.at(i), subArr.at(i)));\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\tif (it->second.compare(subArr.at(i)) == 0) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\treturn flag;\r\n\t}\r\n} ;\r\n\r\n````\r\nend","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}